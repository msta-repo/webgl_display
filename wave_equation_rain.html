<!DOCTYPE html>
<html>

<head>
    <title>2D Wave Equation Solver</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="glCanvas"></canvas>
    <script>
        async function loadShaderSource(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to load shader: ${url}`);
            }
            return await response.text();
        }






        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function createTexture(gl, width, height, data = null) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return texture;
        }

        function createFramebuffer(gl, texture) {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            return fb;
        }


                // Mouse state tracking
        let mouseState = {
            isDown: false,
            x: 0,
            y: 0,
            normalizedX: 0,  // [0, 1] range
            normalizedY: 0   // [0, 1] range
        };

        // Mouse event handlers
        function setupMouseHandlers(canvas) {
            canvas.addEventListener('mousedown', (e) => {
                mouseState.isDown = true;
                updateMousePosition(canvas, e);
            });

            canvas.addEventListener('mouseup', () => {
                mouseState.isDown = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                updateMousePosition(canvas, e);
            });

            canvas.addEventListener('mouseleave', () => {
                mouseState.isDown = false;
            });
        }

        function updateMousePosition(canvas, event) {
            const rect = canvas.getBoundingClientRect();
            mouseState.x = event.clientX - rect.left;
            mouseState.y = event.clientY - rect.top;
            
            // Normalize to [0, 1] range
            mouseState.normalizedX = mouseState.x / canvas.width;
            mouseState.normalizedY = 1.0 - (mouseState.y / canvas.height); // Flip Y for WebGL coordinates
        }

        function addGaussianPulse(gl, texture, width, height, normalizedX, normalizedY) {
            // Create a temporary buffer to read the current texture data
            const currentData = new Float32Array(width * height * 4);
            
            // Bind framebuffer to read from texture
            const tempFb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, tempFb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            
            gl.readPixels(0, 0, width, height, gl.RGBA, gl.FLOAT, currentData);
            
            // Clean up temporary framebuffer
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.deleteFramebuffer(tempFb);

            // Convert normalized coordinates to texture coordinates
            const pulseX = Math.floor(normalizedX * width);
            const pulseY = Math.floor(normalizedY * height);
            const pulseAmplitude = 1.0;  //  amount to add
            const pulseWidth = 1.0;     // Size of the spot

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const dx = x - pulseX;
                    const dy = y - pulseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const value = pulseAmplitude * Math.exp(-dist * dist / pulseWidth);

                    // Add the heat pulse to the existing data
                    currentData[idx] += value;     // R
                    currentData[idx + 1] += value; // G
                    currentData[idx + 2] += value; // B
                    // Alpha channel is unchanged
                }
            }

            // Update the texture with the combined data
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.FLOAT, currentData);
        }

        function addRandomGaussianPulse(gl, texture, width, height, x, y, amp, sigx, sigy, phi) {
            // Create a temporary buffer to read the current texture data
            const currentData = new Float32Array(width * height * 4);
            
            // Bind framebuffer to read from texture
            const tempFb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, tempFb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            
            gl.readPixels(0, 0, width, height, gl.RGBA, gl.FLOAT, currentData);
            
            // Clean up temporary framebuffer
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.deleteFramebuffer(tempFb);

            // Convert normalized coordinates to texture coordinates
            const pulseX = Math.floor(x * width);
            const pulseY = Math.floor(y * height);


            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;

                    
                    const dx = x - pulseX;
                    const dy = y - pulseY;
                    
                    const dxprime = dx*Math.cos(phi) + dy*Math.sin(phi);
                    const dyprime = -dx*Math.sin(phi) + dy*Math.cos(phi);
 
                    const value = amp * Math.exp(-dxprime* dxprime / (2 *sigx*sigx)  - dyprime * dyprime / (2 *sigy*sigy));

                    // Add the heat pulse to the existing data
                    currentData[idx] += value;     // R
                    currentData[idx + 1] += value; // G
                    currentData[idx + 2] += value; // B
                    // Alpha channel is unchanged
                }
            }

            // Update the texture with the combined data
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.FLOAT, currentData);
        }


        async function init() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                console.error('WebGL not supported');
                return;
            }

            // Check for required extensions
            const floatExt = gl.getExtension('OES_texture_float');
            if (!floatExt) {
                console.error('OES_texture_float extension not supported');
                alert('Your browser does not support floating point textures. This simulation requires WebGL with OES_texture_float extension.');
                return;
            }

            // Optional but recommended for better compatibility
            const floatLinearExt = gl.getExtension('OES_texture_float_linear');
            if (!floatLinearExt) {
                console.warn('OES_texture_float_linear not supported - filtering may be limited');
            }

            const simWidth = Math.floor(window.innerWidth/2);
            const simHeight = Math.floor(window.innerHeight/2);

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            setupMouseHandlers(canvas);

            let vsSource, computeSource, displaySource;
            try {
                vsSource = await loadShaderSource("vertex.glsl");
                computeSource = await loadShaderSource("compute_wave.glsl");
                displaySource = await loadShaderSource("display_wave.glsl");
            } catch (error) {
                console.error("Error loading shaders:", error);
                return;
            }

            const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vsSource);
            const computeFragShader = compileShader(gl, gl.FRAGMENT_SHADER, computeSource);
            const displayFragShader = compileShader(gl, gl.FRAGMENT_SHADER, displaySource);

            if (!vertexShader || !computeFragShader || !displayFragShader) {
                console.error("Shader compilation failed!");
                return;
            }

            const computeProgram = createProgram(gl, vertexShader, computeFragShader);
            const displayProgram = createProgram(gl, vertexShader, displayFragShader);

            // Create initial condition using Float32Array
            const initialData = new Float32Array(simWidth * simHeight * 4);
            for (let y = 0; y < simHeight; y++) {
                for (let x = 0; x < simWidth; x++) {
                    const idx = (y * simWidth + x) * 4;
                    const dx = x - simWidth / 2;
                    const dy = y - simHeight / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    // Gaussian pulse - now can be any float value
                    const value = 0.0*Math.exp(-dist * dist / 500.0) * 1.0;
                    
                    initialData[idx] = value;     // R
                    initialData[idx + 1] = value; // G
                    initialData[idx + 2] = value; // B
                    initialData[idx + 3] = value;   // A
                }
            }
            
            const texture0 = createTexture(gl, simWidth, simHeight, initialData);
            const texture1 = createTexture(gl, simWidth, simHeight, initialData);
            const texture2 = createTexture(gl, simWidth, simHeight, null);

            const framebuffer0 = createFramebuffer(gl, texture0);
            const framebuffer1 = createFramebuffer(gl, texture1);
            const framebuffer2 = createFramebuffer(gl, texture2);
            
            const textures = [texture0, texture1, texture2];
            const framebuffers = [framebuffer0, framebuffer1, framebuffer2];

            const vertices = new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                1, 1
            ]);

            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            // Get uniform locations for compute program
            gl.useProgram(computeProgram);
            const computePosLoc = gl.getAttribLocation(computeProgram, 'aPosition');
            const computePsiCurrentLoc = gl.getUniformLocation(computeProgram, 'u_psi_current');
            const computePsiPreviousLoc = gl.getUniformLocation(computeProgram, 'u_psi_previous');
            const computeResLoc = gl.getUniformLocation(computeProgram, 'u_resolution');
            const computeDtLoc = gl.getUniformLocation(computeProgram, 'u_dt');
            const computeDLoc = gl.getUniformLocation(computeProgram, 'u_D');
            const computetLoc = gl.getUniformLocation(computeProgram, 'u_t');
            const computeAttenuateLoc = gl.getUniformLocation(computeProgram, 'u_attenuate');

            // Get uniform locations for display program
            gl.useProgram(displayProgram);
            const displayPosLoc = gl.getAttribLocation(displayProgram, 'aPosition');
            const displayPsiLoc = gl.getUniformLocation(displayProgram, 'u_psi');
            const displayResLoc = gl.getUniformLocation(displayProgram, 'u_resolution');
            
            const D = 0.075;
            const dt = 0.0005;
            let t = 0;
            let currentRead = 0;

            let frameCount = 0;
            let pulseEveryNFrames = 200; // Add a pulse every 60 frames

            function render() {
                t = t + dt;

                const readCurrentIndex = currentRead;
                const readPreviousIndex = (currentRead + 1) % 3;
                const writeNextIndex = (currentRead + 2) % 3;
                
                const readCurrentTexture = textures[readCurrentIndex];
                const readPreviousTexture = textures[readPreviousIndex];
                const writeNextFramebuffer = framebuffers[writeNextIndex];

                
                    // === ADD PULSES FIRST (before binding compute framebuffer) ===
                frameCount++;
                if (frameCount % pulseEveryNFrames === 0) {
                    let x = Math.random();
                    let y = Math.random();
                    let amp = Math.random();
                    let sigma = Math.random();
                    let phi = 0.9;
                    let sigx = Math.random()*3+0.1;
                    let sigy = Math.random()*3+0.1;

                    addRandomGaussianPulse(gl, textures[readCurrentIndex], simWidth, simHeight, x, y, amp, sigx,sigy, phi);
                    addRandomGaussianPulse(gl, textures[readPreviousIndex], simWidth, simHeight, x, y,amp, sigx,sigy, phi);
                    pulseEveryNFrames = Math.floor(Math.random() * 80) + 1;
                }

                if (mouseState.isDown) {
                    addGaussianPulse(gl, textures[readCurrentIndex], simWidth, simHeight, 
                                    mouseState.normalizedX, mouseState.normalizedY);
                    addGaussianPulse(gl, textures[readPreviousIndex], simWidth, simHeight, 
                                    mouseState.normalizedX, mouseState.normalizedY);
                }

                // === COMPUTE STEP ===
                gl.bindFramebuffer(gl.FRAMEBUFFER, writeNextFramebuffer);
                gl.viewport(0, 0, simWidth, simHeight);
                gl.useProgram(computeProgram);


                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, readCurrentTexture);
                gl.uniform1i(computePsiCurrentLoc, 0);

                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, readPreviousTexture);
                gl.uniform1i(computePsiPreviousLoc, 1);
                
                gl.uniform2f(computeResLoc, simWidth, simHeight);
                gl.uniform1f(computeDtLoc, dt);
                gl.uniform1f(computeDLoc, D);
                gl.uniform1f(computetLoc, t);
                gl.uniform1f(computeAttenuateLoc, 0.002);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.enableVertexAttribArray(computePosLoc);
                gl.vertexAttribPointer(computePosLoc, 2, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);


               


                // === DISPLAY STEP ===
                const displayTexture = textures[writeNextIndex];



                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.useProgram(displayProgram);

                gl.uniform2f(displayResLoc, canvas.width, canvas.height);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, displayTexture);
                gl.uniform1i(displayPsiLoc, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.enableVertexAttribArray(displayPosLoc);
                gl.vertexAttribPointer(displayPosLoc, 2, gl.FLOAT, false, 0, 0);

                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                currentRead = writeNextIndex;

                requestAnimationFrame(render);
            }

            render();
        }

        init().catch(error => {
            console.error("Initialization error:", error);
        });
    </script>
</body>

</html>