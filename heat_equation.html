<!DOCTYPE html>
<html>

<head>
    <title>Heat Equation Solver</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            touch-action: none; /* Prevent default touch behaviors like scrolling */
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="glCanvas"></canvas>
    <script>
        // Load shader from external file
        async function loadShaderSource(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to load shader: ${url}`);
            }
            return await response.text();
        }

        // Compile shader helper
        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create a shader program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Create a texture
        function createTexture(gl, width, height, data = null) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA,  gl.FLOAT, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return texture;
        }

        // Create a framebuffer
        function createFramebuffer(gl, texture) {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            return fb;
        }


        // Mouse/Touch state tracking
        let mouseState = {
            isDown: false,
            x: 0,
            y: 0,
            normalizedX: 0,  // [0, 1] range
            normalizedY: 0,   // [0, 1] range
            isTouch: false    // Track if input is from touch
        };

        // Touch stack - stores up to 5 active touch positions
        let touchStack = [];
        const MAX_TOUCHES = 5;

        // Update position helper function (used by both mouse and touch)
        function updatePosition(canvas, clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            mouseState.x = clientX - rect.left;
            mouseState.y = clientY - rect.top;
            
            // Normalize to [0, 1] range
            mouseState.normalizedX = mouseState.x / canvas.width;
            mouseState.normalizedY = 1.0 - (mouseState.y / canvas.height); // Flip Y for WebGL coordinates
        }

        // Mouse event handlers
        function setupMouseHandlers(canvas) {
            canvas.addEventListener('mousedown', (e) => {
                mouseState.isDown = true;
                mouseState.isTouch = false;
                updatePosition(canvas, e.clientX, e.clientY);
            });

            canvas.addEventListener('mouseup', () => {
                mouseState.isDown = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                updatePosition(canvas, e.clientX, e.clientY);
            });

            canvas.addEventListener('mouseleave', () => {
                mouseState.isDown = false;
            });
        }

        // Touch event handlers with multitouch support
        function setupTouchHandlers(canvas) {
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mouseState.isTouch = true;
                
                // Add all new touches to the stack (up to MAX_TOUCHES)
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    // Check if this touch is already in the stack
                    if (touchStack.some(t => t.id === touch.identifier)) {
                        continue;
                    }
                    
                    // Only add if we haven't reached the max
                    if (touchStack.length < MAX_TOUCHES) {
                        const rect = canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        
                        touchStack.push({
                            id: touch.identifier,
                            normalizedX: x / canvas.width,
                            normalizedY: 1.0 - (y / canvas.height)
                        });
                    }
                }
                
                mouseState.isDown = touchStack.length > 0;
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                // Remove ended touches from stack using changedTouches
                const endedTouchIds = new Set();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    endedTouchIds.add(e.changedTouches[i].identifier);
                }
                
                touchStack = touchStack.filter(touch => !endedTouchIds.has(touch.id));
                mouseState.isDown = touchStack.length > 0;
            });

            canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                touchStack = [];
                mouseState.isDown = false;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                // Update positions of existing touches in stack
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    const stackIndex = touchStack.findIndex(t => t.id === touch.identifier);
                    
                    if (stackIndex !== -1) {
                        const rect = canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        
                        touchStack[stackIndex].normalizedX = x / canvas.width;
                        touchStack[stackIndex].normalizedY = 1.0 - (y / canvas.height);
                    }
                }
            });
        }


        // Main initialization function (async)
        async function init() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');


             // Check for required extensions
            const floatExt = gl.getExtension('OES_texture_float');
            if (!floatExt) {
                console.error('OES_texture_float extension not supported');
                alert('Your browser does not support floating point textures. This simulation requires WebGL with OES_texture_float extension.');
                return;
            }

            // Optional but recommended for better compatibility
            const floatLinearExt = gl.getExtension('OES_texture_float_linear');
            if (!floatLinearExt) {
                console.warn('OES_texture_float_linear not supported - filtering may be limited');
            }
            // Simulation resolution
            const simWidth = Math.floor(window.innerWidth/4);
            const simHeight = Math.floor(window.innerHeight/4);

            // Set canvas size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resizeCanvas);


            resizeCanvas();

            // Setup both mouse and touch handlers
            setupMouseHandlers(canvas);
            setupTouchHandlers(canvas);

            // Load vertex shader
            let vsSource;
            try {
                vsSource = await loadShaderSource("vertex.glsl");
                console.log("Vertex shader loaded successfully");
            } catch (error) {
                console.error("error loading vertex shader:", error);
                return;
            }

            // Load compute shader
            let computeSource;
            try {
                computeSource = await loadShaderSource("compute_diff.glsl");
                console.log("Compute shader loaded successfully");
            } catch (error) {
                console.error("Error loading compute shader:", error);
                return;
            }

            // Load display shader
            let displaySource;
            try {
                displaySource = await loadShaderSource("display_diff.glsl");
                console.log("Display shader loaded successfully");
            } catch (error) {
                console.error("Error loading display shader:", error);
                return;
            }

            // Compile shaders
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vsSource);
            const computeFragShader = compileShader(gl, gl.FRAGMENT_SHADER, computeSource);
            const displayFragShader = compileShader(gl, gl.FRAGMENT_SHADER, displaySource);

            if (!vertexShader || !computeFragShader || !displayFragShader) {
                console.error("Shader compilation failed!");
                return;
            }

            // Create programs
            const computeProgram = createProgram(gl, vertexShader, computeFragShader);
            const displayProgram = createProgram(gl, vertexShader, displayFragShader);

            // Create initial condition (hot spot in center)
            const initialData = new Float32Array(simWidth * simHeight * 4);
            for (let y = 0; y < simHeight; y++) {
                for (let x = 0; x < simWidth; x++) {
                    const idx = (y * simWidth + x) * 4;
                    const dx = x - simWidth / 2;
                    const dy = y - simHeight / 2;
                    const dist = Math.sqrt(dx * dx + 20*dy * dy);
                    const value = dist < 30.0 ? 0.0 : 0.0; // Hot spot
                    //const value =1.0;
                    initialData[idx] = value;     // R
                    initialData[idx + 1] = value; // G
                    initialData[idx + 2] = value; // B
                    initialData[idx + 3] = 1.0;   // A
                }
            }

            // Create ping-pong textures and framebuffers
            const texture0 = createTexture(gl, simWidth, simHeight, initialData);
            const texture1 = createTexture(gl, simWidth, simHeight, null);
            const framebuffer0 = createFramebuffer(gl, texture0);
            const framebuffer1 = createFramebuffer(gl, texture1);

            // Define a fullscreen quad
            const vertices = new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                1, 1
            ]);

            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            // Get attribute and uniform locations for compute program
            gl.useProgram(computeProgram);
            const computePosLoc = gl.getAttribLocation(computeProgram, 'aPosition');
            const computePsiLoc = gl.getUniformLocation(computeProgram, 'u_psi');
            const computeResLoc = gl.getUniformLocation(computeProgram, 'u_resolution');
            const computeDtLoc = gl.getUniformLocation(computeProgram, 'u_dt');
            const computeDLoc = gl.getUniformLocation(computeProgram, 'u_D');
            
            // New uniforms for heat addition
            const computeAddHeatLoc = gl.getUniformLocation(computeProgram, 'u_addHeat');
            const computeHeatPosLoc = gl.getUniformLocation(computeProgram, 'u_heatPos');
            const computeHeatAmplitudeLoc = gl.getUniformLocation(computeProgram, 'u_heatAmplitude');
            const computeHeatWidthLoc = gl.getUniformLocation(computeProgram, 'u_heatWidth');

            // Get attribute and uniform locations for display program
            gl.useProgram(displayProgram);
            const displayPosLoc = gl.getAttribLocation(displayProgram, 'aPosition');
            const displayPsiLoc = gl.getUniformLocation(displayProgram, 'u_psi');
            const displayResLoc = gl.getUniformLocation(displayProgram, 'u_resolution');
            
            // Simulation parameters
            const D = 17;  // Diffusion coefficient
            dt = 0.01; // Time step (must satisfy stability: dt * D / h^2 <= 0.25)
            
            // Heat pulse parameters
            const pulseAmplitude = 0.5;
            const pulseWidth = 10.0;

            let currentRead = 0; // 0 or 1 (ping-pong)
            let currentTouchIndex = 0; // Index for cycling through touch stack

            // Render loop
            function render() {
                // === COMPUTE STEP: Read from current, write to next ===
                const readTexture = currentRead === 0 ? texture0 : texture1;
                const writeFramebuffer = currentRead === 0 ? framebuffer1 : framebuffer0;

                gl.bindFramebuffer(gl.FRAMEBUFFER, writeFramebuffer);
                gl.viewport(0, 0, simWidth, simHeight);
                gl.useProgram(computeProgram);

                // Bind texture to read from
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, readTexture);
                gl.uniform1i(computePsiLoc, 0);
                gl.uniform2f(computeResLoc, simWidth, simHeight);
                gl.uniform1f(computeDtLoc, dt);
                gl.uniform1f(computeDLoc, D);
                
                // Set heat addition uniforms
                if (mouseState.isDown) {
                    gl.uniform1i(computeAddHeatLoc, 1);
                    
                    let heatX, heatY, heatWidth;
                    
                    if (mouseState.isTouch && touchStack.length > 0) {
                        // Use touch from stack and cycle through
                        const touch = touchStack[currentTouchIndex];
                        heatX = touch.normalizedX;
                        heatY = touch.normalizedY;
                        heatWidth = pulseWidth * 2.0; // Double the Gaussian width for touch
                        
                        // Move to next touch in stack, wrap around
                        currentTouchIndex = (currentTouchIndex + 1) % touchStack.length;
                    } else {
                        // Use mouse position
                        heatX = mouseState.normalizedX;
                        heatY = mouseState.normalizedY;
                        heatWidth = pulseWidth; // Normal width for mouse
                    }
                    
                    gl.uniform2f(computeHeatPosLoc, heatX, heatY);
                    gl.uniform1f(computeHeatAmplitudeLoc, pulseAmplitude);
                    gl.uniform1f(computeHeatWidthLoc, heatWidth);
                } else {
                    gl.uniform1i(computeAddHeatLoc, 0);
                    currentTouchIndex = 0; // Reset touch index when not touching
                }

                // Set up attributes
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.enableVertexAttribArray(computePosLoc);
                gl.vertexAttribPointer(computePosLoc, 2, gl.FLOAT, false, 0, 0);

                // Draw to framebuffer
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // === DISPLAY STEP: Render result to canvas ===
                const displayTexture = currentRead === 0 ? texture1 : texture0;

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.useProgram(displayProgram);

                gl.uniform2f(displayResLoc, canvas.width, canvas.height);

                // Bind texture to display
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, displayTexture);
                gl.uniform1i(displayPsiLoc, 0);

                // Set up attributes
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.enableVertexAttribArray(displayPosLoc);
                gl.vertexAttribPointer(displayPosLoc, 2, gl.FLOAT, false, 0, 0);

                // Draw to screen
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // Swap ping-pong
                currentRead = 1 - currentRead;

                requestAnimationFrame(render);
            }

            // Start the render loop
            render();
        }

        // Start the application
        init().catch(error => {
            console.error("Initialization error:", error);
        });
    </script>
</body>

</html>