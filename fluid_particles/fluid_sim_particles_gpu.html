<!DOCTYPE html>
<html>
<head>
    <title>2D Wave Equation Solver with GPU Particles</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            font-family: monospace;
            border-radius: 5px;
        }
        #controls label {
            display: block;
            margin: 8px 0;
        }
        #controls input[type="range"] {
            width: 200px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="controls">
        <label>
            Particles: <span id="particleCountDisplay">15000</span>
            <input type="range" id="particleCount" min="256" max="32768" step="256" value="15000">
        </label>
        <label>
            Trail Fade: <span id="trailFadeDisplay">9.99</span>
            <input type="range" id="trailFade" min="0.0" max="9.999" step="0.00005" value="9.99">
        </label>
    </div>
    <script>
        // Mouse/Touch state tracking
        let mouseState = {
            isDown: false,
            x: 0,
            y: 0,
            prevX: 0,
            prevY: 0,
            normalizedX: 0,
            normalizedY: 0,
            prevNormalizedX: 0,
            prevNormalizedY: 0,
            velocityX: 0,
            velocityY: 0
        };

        // Update position helper function
        function updatePosition(canvas, clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            
            mouseState.prevX = mouseState.x;
            mouseState.prevY = mouseState.y;
            mouseState.prevNormalizedX = mouseState.normalizedX;
            mouseState.prevNormalizedY = mouseState.normalizedY;
            
            mouseState.x = clientX - rect.left;
            mouseState.y = clientY - rect.top;
            
            mouseState.normalizedX = mouseState.x / canvas.width;
            mouseState.normalizedY = 1.0 - (mouseState.y / canvas.height);
            
            mouseState.velocityX = mouseState.normalizedX - mouseState.prevNormalizedX;
            mouseState.velocityY = mouseState.normalizedY - mouseState.prevNormalizedY;
        }

        // Mouse event handlers
        function setupMouseHandlers(canvas) {
            canvas.addEventListener('mousedown', (e) => {
                mouseState.isDown = true;
                updatePosition(canvas, e.clientX, e.clientY);
                mouseState.velocityX = 0;
                mouseState.velocityY = 0;
            });

            canvas.addEventListener('mouseup', () => {
                mouseState.isDown = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (mouseState.isDown) {
                    updatePosition(canvas, e.clientX, e.clientY);
                }
            });

            canvas.addEventListener('mouseleave', () => {
                mouseState.isDown = false;
            });
        }

        // Touch event handlers
        function setupTouchHandlers(canvas) {
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mouseState.isDown = true;
                const touch = e.touches[0];
                updatePosition(canvas, touch.clientX, touch.clientY);
                mouseState.velocityX = 0;
                mouseState.velocityY = 0;
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                mouseState.isDown = false;
            });

            canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                mouseState.isDown = false;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    updatePosition(canvas, touch.clientX, touch.clientY);
                }
            });
        }

        // Simulation field class
        class SimField {
            constructor(gl, program, width, height, depth) {
                this.gl = gl;
                this.program = program;
                this.height = height;
                this.width = width;
                this.depth = depth;

                this.currentReadIndex = 0;

                // Initialize textures and framebuffers
                this.textures = [];
                this.framebuffers = [];
                for (let i = 0; i < depth; i++){
                    this.textures[i] = createTexture(gl, width, height, null);
                    this.framebuffers[i] = createFramebuffer(gl, this.textures[i]);
                }
            }

            setTextureData(id, data){
                // Delete old texture and framebuffer first
                this.gl.deleteTexture(this.textures[id]);
                this.gl.deleteFramebuffer(this.framebuffers[id]);
                
                // Create new ones with data
                this.textures[id] = createTexture(this.gl, this.width, this.height, data);
                this.framebuffers[id] = createFramebuffer(this.gl, this.textures[id]);
            }

            clear(){
                for (let i = 0; i<this.depth; i++){
                    this.gl.deleteTexture(this.textures[i]);
                    this.gl.deleteFramebuffer(this.framebuffers[i]);
                }
            }

            getCurrentTexture() {
                return this.textures[this.currentReadIndex];
            }

            // Prepare textures and framebuffers for read and write
            swapAndBind(uniformLocations) {
                if(this.depth === 3){
                    const currentReadIndex = this.currentReadIndex;
                    const previousReadIndex = (this.currentReadIndex + 1) % this.depth;
                    const nextWriteIndex = (this.currentReadIndex + 2) % this.depth;
                    
                    // Bind framebuffer for writing
                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffers[nextWriteIndex]);
                    this.gl.viewport(0, 0, this.width, this.height);
                    this.gl.useProgram(this.program);
                    
                    // Bind read textures to texture units
                    this.gl.activeTexture(this.gl.TEXTURE0);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[currentReadIndex]);
                    this.gl.uniform1i(uniformLocations.current, 0);
                    
                    this.gl.activeTexture(this.gl.TEXTURE1);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[previousReadIndex]);
                    this.gl.uniform1i(uniformLocations.previous, 1);
                    
                    // Update internal state
                    this.currentReadIndex = nextWriteIndex;
                    
                    return nextWriteIndex;
                } else if (this.depth === 2) {
                    const readIndex = this.currentReadIndex;
                    const writeIndex = 1 - this.currentReadIndex;
                    
                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffers[writeIndex]);
                    this.gl.viewport(0, 0, this.width, this.height);
                    this.gl.useProgram(this.program);
                    
                    this.gl.activeTexture(this.gl.TEXTURE0);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[readIndex]);
                    this.gl.uniform1i(uniformLocations.current, 0);
                    
                    this.currentReadIndex = writeIndex;
                    return writeIndex;
                }
            }
        }

        async function loadShaderSource(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to load shader: ${url}`);
            }
            return await response.text();
        }

        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function createTexture(gl, width, height, data = null) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return texture;
        }

        function createFramebuffer(gl, texture) {
            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            return fb;
        }

        // Helper function to set mouse interaction uniforms
        function setMouseUniforms(gl, uniforms) {
            if (mouseState.isDown) {
                gl.uniform1i(uniforms.mouseActive, 1);
                gl.uniform2f(uniforms.mousePos, mouseState.normalizedX, mouseState.normalizedY);
                gl.uniform2f(uniforms.mouseVel, mouseState.velocityX * 50.0, mouseState.velocityY * 50.0);
                gl.uniform1f(uniforms.mouseRadius, 0.05);
            } else {
                gl.uniform1i(uniforms.mouseActive, 0);
            }
        }

        async function init() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');

            const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            if (!gl) {
                console.error('WebGL not supported');
                return;
            }

            const floatExt = gl.getExtension('OES_texture_float');
            if (!floatExt) {
                console.error('OES_texture_float extension not supported');
                alert('Your browser does not support floating point textures.');
                return;
            }

            const instancingExt = gl.getExtension('ANGLE_instanced_arrays');
            if (!instancingExt) {
                console.error('ANGLE_instanced_arrays extension not supported');
                alert('Your browser does not support instanced rendering.');
                return;
            }

            // Enable texture sampling in vertex shader
            const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            if (maxVertexTextures === 0) {
                console.error('Vertex texture fetch not supported');
                alert('Your browser does not support vertex texture fetch.');
                return;
            }

            // Setup mouse and touch handlers
            setupMouseHandlers(canvas);
            setupTouchHandlers(canvas);

            const simScale = Math.sqrt(1);
            const simWidth = Math.floor(window.innerWidth*simScale);
            const simHeight = Math.floor(window.innerHeight*simScale);

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Load shaders
            let vsSource, writeSource, computeSource, displaySource;
            let particleComputeSource, particleVsSource;
            let fadeTrailSource, displayCompositeSource;
            try {
                vsSource = await loadShaderSource("vertex.glsl");
                writeSource = await loadShaderSource("write_texture.glsl");
                computeSource = await loadShaderSource("compute_fluid.glsl");
                displaySource = await loadShaderSource("display_fluid.glsl");
                particleComputeSource = await loadShaderSource("compute_particles.glsl");
                particleVsSource = await loadShaderSource("vertex_particles_gpu.glsl");
                fadeTrailSource = await loadShaderSource("fade_trail.glsl");
                displayCompositeSource = await loadShaderSource("display_composite.glsl");
                particleFsSource = await loadShaderSource("particle_fragment.glsl");

                pressureProjectFsSource = await loadShaderSource("pressure_fragment.glsl");
                gradientSubtractFsSource = await loadShaderSource("gradient_subtract.glsl");

            } catch (error) {
                console.error("Error loading shaders:", error);
                return;
            }

            // Compile shaders
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vsSource);
            const writeFragShader = compileShader(gl, gl.FRAGMENT_SHADER, writeSource);
            const computeFragShader = compileShader(gl, gl.FRAGMENT_SHADER, computeSource);
            const displayFragShader = compileShader(gl, gl.FRAGMENT_SHADER, displaySource);
            const particleComputeFragShader = compileShader(gl, gl.FRAGMENT_SHADER, particleComputeSource);
            const particleVertexShader = compileShader(gl, gl.VERTEX_SHADER, particleVsSource);
            const fadeTrailFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fadeTrailSource);
            const displayCompositeFragShader = compileShader(gl, gl.FRAGMENT_SHADER, displayCompositeSource);
            const particleFragShader = compileShader(gl, gl.FRAGMENT_SHADER, particleFsSource);

            const pressureFragShader = compileShader(gl, gl.FRAGMENT_SHADER, pressureProjectFsSource);
            const gradientSubtractShader = compileShader(gl, gl.FRAGMENT_SHADER, gradientSubtractFsSource)

            if (!vertexShader || !writeFragShader || !computeFragShader || !displayFragShader || 
                !particleComputeFragShader || !particleVertexShader || !particleFragShader ||
                !fadeTrailFragShader || !displayCompositeFragShader || !pressureFragShader || !gradientSubtractShader) {
                console.error("Shader compilation failed!");
                return;
            }

            // Create programs
            const computeProgram = createProgram(gl, vertexShader, computeFragShader);
            const pressureComputeProgram = createProgram(gl, vertexShader, pressureFragShader);
            const gradientSubtractProgram = createProgram(gl, vertexShader, gradientSubtractShader);

            const displayProgram = createProgram(gl, vertexShader, displayFragShader);
            const particleComputeProgram = createProgram(gl, vertexShader, particleComputeFragShader);
            const particleRenderProgram = createProgram(gl, particleVertexShader, particleFragShader);
            const fadeTrailProgram = createProgram(gl, vertexShader, fadeTrailFragShader);
            const displayCompositeProgram = createProgram(gl, vertexShader, displayCompositeFragShader);

            // Simulation parameters
            const simParams = {
                D: 0.045,
                dt: 0.24,
                get numSubsteps() { return Math.ceil(this.dt / 0.12); },
                trailFade: parseFloat(document.getElementById('trailFade').value),
                omega: 1.7,
                PRESSURE_ITERATIONS: 13,
                pressure_project: 1.0, 
                pressureResolutionFactor: 12,
                usePeriodic: 1.0
            };

            // Initialize fluid field
            const initialData = new Float32Array(simWidth * simHeight * 4);
            for (let y = 0; y < simHeight; y++) {
                for (let x = 0; x < simWidth; x++) {
                    const idx = (y * simWidth + x) * 4;
                    let dx = x - simWidth/2;
                    let dy = y - simHeight/2;
                    let r = Math.sqrt(dx*dx + dy*dy);

                    let b = 0.0;
                    if (Math.abs(r)<100.0){
                        b = 1.0;
                    }
                    let phi = Math.atan2(dy,dx);

                    initialData[idx] = (Math.random()-0.5)*0.5*0.2;
                    initialData[idx + 1] = (Math.random()-0.5)*0.5*0.2;
                    initialData[idx + 2] = 1.0;
                    initialData[idx + 3] = Math.pow(Math.sin(x*20)*Math.cos(y*20), 2);
                }
            }
            
            const fluidField = new SimField(gl, computeProgram, simWidth, simHeight, 2);
            fluidField.setTextureData(0, initialData);

            // ==================== PARTICLE SETUP ====================
            let PARTICLE_COUNT = parseInt(document.getElementById('particleCount').value);
            let PARTICLE_TEX_WIDTH = 256;
            let PARTICLE_TEX_HEIGHT = Math.ceil(PARTICLE_COUNT / PARTICLE_TEX_WIDTH);
            PARTICLE_COUNT = PARTICLE_TEX_WIDTH * PARTICLE_TEX_HEIGHT;
            
            function initializeParticles() {
                const particleInitialData = new Float32Array(PARTICLE_TEX_WIDTH * PARTICLE_TEX_HEIGHT * 4);
                
                const particlesPerRow = Math.ceil(Math.sqrt(PARTICLE_COUNT));
                const particlesPerCol = Math.ceil(PARTICLE_COUNT / particlesPerRow);
                const w = 2.0 / (Math.max(particlesPerRow, particlesPerCol) - 1);
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const row = Math.floor(i / particlesPerRow);
                    const col = i % particlesPerRow;
                    
                    const x = col * w;
                    const y = row * w;
                    
                    const centerX = -(particlesPerRow - 1) * w / 2;
                    const centerY = -(particlesPerCol - 1) * w / 2;
                    
                    particleInitialData[i * 4] = x + centerX;
                    particleInitialData[i * 4 + 1] = y + centerY;
                    particleInitialData[i * 4 + 2] = 0.0;
                    particleInitialData[i * 4 + 3] = 0.0;
                }
                return particleInitialData;
            }
            
            let particleInitialData = initializeParticles();
            
            let particleField = new SimField(gl, particleComputeProgram, PARTICLE_TEX_WIDTH, PARTICLE_TEX_HEIGHT, 2);    
            particleField.setTextureData(0, particleInitialData);
            
            // pressure 

            let pressureField = new SimField(gl, pressureComputeProgram, Math.floor(simWidth/simParams.pressureResolutionFactor), Math.floor(simHeight/simParams.pressureResolutionFactor), 2); 


            // Trail textures
            const trailField = new SimField(gl, fadeTrailProgram, simWidth, simHeight, 2);
            
            // Quad for particle sprite
            const particleQuad = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const particleQuadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, particleQuadBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, particleQuad, gl.STATIC_DRAW);
            
            // Instance IDs
            function createInstanceIDs(count) {
                const ids = new Float32Array(count);
                for (let i = 0; i < count; i++) {
                    ids[i] = i;
                }
                return ids;
            }
            
            let instanceIDs = createInstanceIDs(PARTICLE_COUNT);
            let instanceIDBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, instanceIDBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, instanceIDs, gl.STATIC_DRAW);

            // ==================== SHADER UNIFORMS ====================
            // Fluid compute uniforms
            gl.useProgram(computeProgram);
            const fluidUniforms = {
                pos: gl.getAttribLocation(computeProgram, 'aPosition'),
                fieldCurrent: gl.getUniformLocation(computeProgram, 'fields_current'),
                resolution: gl.getUniformLocation(computeProgram, 'resolution'),
                dt: gl.getUniformLocation(computeProgram, 'dt'),
                D: gl.getUniformLocation(computeProgram, 'D'),
                t: gl.getUniformLocation(computeProgram, 't'),
                usePeriodic: gl.getUniformLocation(computeProgram, 'usePeriodic'),
                mouseActive: gl.getUniformLocation(computeProgram, 'u_mouseActive'),
                mousePos: gl.getUniformLocation(computeProgram, 'u_mousePos'),
                mouseVel: gl.getUniformLocation(computeProgram, 'u_mouseVel'),
                mouseRadius: gl.getUniformLocation(computeProgram, 'u_mouseRadius'),
                pressure_project: gl.getUniformLocation(computeProgram, 'pressure_project')
            };

            // pressure projection uniforms
            gl.useProgram(pressureComputeProgram);
            const pressureUniforms = {
                pos: gl.getAttribLocation(pressureComputeProgram, 'aPosition'),
                fieldCurrent: gl.getUniformLocation(pressureComputeProgram, 'fields_current'),
                velocity: gl.getUniformLocation(pressureComputeProgram, 'velocity'),
                resolution: gl.getUniformLocation(pressureComputeProgram, 'resolution'),
                usePeriodic: gl.getUniformLocation(pressureComputeProgram, 'usePeriodic'),
                omega: gl.getUniformLocation(pressureComputeProgram, 'omega'),
                redOrBlack: gl.getUniformLocation(pressureComputeProgram, 'redOrBlack'),
                pressureResolutionFactor: gl.getUniformLocation(pressureComputeProgram, 'pressureResolutionFactor')
            }

            // pressure projection uniforms
            gl.useProgram(gradientSubtractProgram);
            const gradientSubtractUniforms = {
                pos: gl.getAttribLocation(gradientSubtractProgram, 'aPosition'),
                fieldCurrent: gl.getUniformLocation(gradientSubtractProgram, 'fields_current'),
                pressure: gl.getUniformLocation(gradientSubtractProgram, 'pressure'),
                resolution: gl.getUniformLocation(gradientSubtractProgram, 'resolution'),
                usePeriodic: gl.getUniformLocation(gradientSubtractProgram, 'usePeriodic'),
                omega: gl.getUniformLocation(gradientSubtractProgram, 'omega'),
                pressureResolutionFactor: gl.getUniformLocation(gradientSubtractProgram, 'pressureResolutionFactor')
                
            }

            // Fluid display uniforms
            gl.useProgram(displayProgram);
            const displayUniforms = {
                pos: gl.getAttribLocation(displayProgram, 'aPosition'),
                field: gl.getUniformLocation(displayProgram, 'fields_current'),
                resolution: gl.getUniformLocation(displayProgram, 'resolution')
            };
            
            // Particle compute uniforms
            gl.useProgram(particleComputeProgram);
            const particleComputeUniforms = {
                pos: gl.getAttribLocation(particleComputeProgram, 'aPosition'),
                positions: gl.getUniformLocation(particleComputeProgram, 'particlePositions'),
                velocity: gl.getUniformLocation(particleComputeProgram, 'velocityField'),
                texSize: gl.getUniformLocation(particleComputeProgram, 'particleTexSize'),
                dt: gl.getUniformLocation(particleComputeProgram, 'dt'),
                t: gl.getUniformLocation(particleComputeProgram, 't')
            };

            // Particle render uniforms
            gl.useProgram(particleRenderProgram);
            const particleRenderUniforms = {
                quad: gl.getAttribLocation(particleRenderProgram, 'aPosition'),
                instanceID: gl.getAttribLocation(particleRenderProgram, 'aInstanceID'),
                positions: gl.getUniformLocation(particleRenderProgram, 'particlePositions'),
                resolution: gl.getUniformLocation(particleRenderProgram, 'resolution'),
                texSize: gl.getUniformLocation(particleRenderProgram, 'particleTexSize'),
                size: gl.getUniformLocation(particleRenderProgram, 'particleSize'),
                fadeAmount: gl.getUniformLocation(particleRenderProgram, 'fadeAmount'),
                t: gl.getUniformLocation(particleRenderProgram, 't')
            };

            // Trail fade uniforms
            gl.useProgram(fadeTrailProgram);
            const trailUniforms = {
                pos: gl.getAttribLocation(fadeTrailProgram, 'aPosition'),
                prev: gl.getUniformLocation(fadeTrailProgram, 'previousTrail'),
                resolution: gl.getUniformLocation(fadeTrailProgram, 'resolution'),
                fadeAmount: gl.getUniformLocation(fadeTrailProgram, 'fadeAmount')
            };
            
            // Composite display uniforms
            gl.useProgram(displayCompositeProgram);
            const compositeUniforms = {
                pos: gl.getAttribLocation(displayCompositeProgram, 'aPosition'),
                fluid: gl.getUniformLocation(displayCompositeProgram, 'fluidTexture'),
                trail: gl.getUniformLocation(displayCompositeProgram, 'trailTexture'),
                resolution: gl.getUniformLocation(displayCompositeProgram, 'resolution')
            };
            
            // UI Controls
            document.getElementById('particleCount').addEventListener('input', (e) => {
                const newCount = parseInt(e.target.value);
                document.getElementById('particleCountDisplay').textContent = newCount;
                
                PARTICLE_COUNT = newCount;
                PARTICLE_TEX_HEIGHT = Math.ceil(PARTICLE_COUNT / PARTICLE_TEX_WIDTH);
                PARTICLE_COUNT = PARTICLE_TEX_WIDTH * PARTICLE_TEX_HEIGHT;
                
                particleInitialData = initializeParticles();
                
                particleField.clear();
                
                particleField = new SimField(gl, particleComputeProgram, PARTICLE_TEX_WIDTH, PARTICLE_TEX_HEIGHT, 2);
                particleField.setTextureData(0, particleInitialData);
                
                instanceIDs = createInstanceIDs(PARTICLE_COUNT);
                gl.bindBuffer(gl.ARRAY_BUFFER, instanceIDBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, instanceIDs, gl.STATIC_DRAW);

                // Clear trail textures
                gl.bindFramebuffer(gl.FRAMEBUFFER, trailField.framebuffers[0]);
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, trailField.framebuffers[1]);
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                trailField.currentReadIndex = 0;
            });
            
            document.getElementById('trailFade').addEventListener('input', (e) => {
                simParams.trailFade = parseFloat(e.target.value);
                document.getElementById('trailFadeDisplay').textContent = simParams.trailFade.toFixed(3);
            });

            let t = 0;


            function render() {
                t = t + simParams.dt;

                // ==================== FLUID COMPUTE ====================
                for (let substep = 0; substep < simParams.numSubsteps; substep++) {
                    fluidField.swapAndBind({
                        current: fluidUniforms.fieldCurrent,
                        previous: fluidUniforms.fieldPrevious
                    });

                    gl.uniform2f(fluidUniforms.resolution, simWidth, simHeight);
                    gl.uniform1f(fluidUniforms.dt, simParams.dt / simParams.numSubsteps);  
                    gl.uniform1f(fluidUniforms.D, simParams.D);
                    gl.uniform1f(fluidUniforms.t, t + substep * simParams.dt / simParams.numSubsteps);
                    gl.uniform1f(fluidUniforms.usePeriodic, simParams.usePeriodic);
                    gl.uniform1f(fluidUniforms.pressure_project, simParams.pressure_project)

                    setMouseUniforms(gl, fluidUniforms);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    if (simParams.pressure_project === 1.0){
                    // insert pressure projection
                    pressureField.swapAndBind({
                        current: pressureUniforms.fieldCurrent
                    });

                    // bind velocity field from fluid texture
                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(gl.TEXTURE_2D, fluidField.getCurrentTexture());
                    gl.uniform1i(pressureUniforms.velocity,1);

                    // set pressure projection uniforms
                    
                    for (let iter = 0; iter < simParams.PRESSURE_ITERATIONS; iter++) {
                        pressureField.swapAndBind({
                            current: pressureUniforms.fieldCurrent
                        });

                        gl.uniform2f(pressureUniforms.resolution, simWidth, simHeight);

                        gl.uniform1f(pressureUniforms.usePeriodic, 1.0);
                        gl.uniform1f(pressureUniforms.omega, simParams.omega);
                        gl.uniform1f(pressureUniforms.pressureResolutionFactor, simParams.pressureResolutionFactor);

                        gl.uniform1i(pressureUniforms.redOrBlack, iter % 2);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    }
                    
                    // gradient subtract shader calculation
                    // reads update velocities from pressureField and writes to fluid computation shader framebuffer

                    // After pressure iterations, swap fluid field one more time
                    const nextFluidIndex = (fluidField.currentReadIndex + 2) % 3;
                    gl.bindFramebuffer(gl.FRAMEBUFFER, fluidField.framebuffers[nextFluidIndex]);
                    gl.viewport(0, 0, simWidth, simHeight);
                    gl.useProgram(gradientSubtractProgram);

                    // Bind OLD velocity (from fluid compute)
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, fluidField.getCurrentTexture());
                    gl.uniform1i(gradientSubtractUniforms.fieldCurrent, 0);

                    // Bind pressure
                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(gl.TEXTURE_2D, pressureField.getCurrentTexture());
                    gl.uniform1i(gradientSubtractUniforms.pressure, 1);

                    gl.uniform2f(gradientSubtractUniforms.resolution, simWidth, simHeight);
                    gl.uniform1f(gradientSubtractUniforms.usePeriodic, 1.0);
                    gl.uniform1f(gradientSubtractUniforms.pressureResolutionFactor, simParams.pressureResolutionFactor);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    // Update fluid field index
                    fluidField.currentReadIndex = nextFluidIndex;

                    }

                }


                



                // ==================== PARTICLE COMPUTE (GPU) ====================
                particleField.swapAndBind({
                    current: particleComputeUniforms.positions
                });
                
                // Bind velocity field
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, fluidField.getCurrentTexture());
                gl.uniform1i(particleComputeUniforms.velocity, 1);
                
                gl.uniform2f(particleComputeUniforms.texSize, PARTICLE_TEX_WIDTH, PARTICLE_TEX_HEIGHT);
                gl.uniform1f(particleComputeUniforms.dt, simParams.dt); 
                gl.uniform1f(particleComputeUniforms.t, t);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.enableVertexAttribArray(particleComputeUniforms.pos);
                gl.vertexAttribPointer(particleComputeUniforms.pos, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // ==================== TRAIL FADE PASS ====================
                trailField.swapAndBind({
                    current: trailUniforms.prev
                });

                gl.uniform2f(trailUniforms.resolution, simWidth, simHeight);
                gl.uniform1f(trailUniforms.fadeAmount, simParams.trailFade); 
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                // ==================== DRAW PARTICLES TO TRAIL ====================
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

                gl.useProgram(particleRenderProgram);
                gl.uniform2f(particleRenderUniforms.resolution, simWidth, simHeight);
                gl.uniform2f(particleRenderUniforms.texSize, PARTICLE_TEX_WIDTH, PARTICLE_TEX_HEIGHT);
                gl.uniform1f(particleRenderUniforms.size, 0.04/simScale);
                gl.uniform1f(particleRenderUniforms.fadeAmount, simParams.trailFade);
                gl.uniform1f(particleRenderUniforms.t, t);

                // Bind particle position texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, particleField.getCurrentTexture());
                gl.uniform1i(particleRenderUniforms.positions, 0);
                
                // Bind quad vertices
                gl.bindBuffer(gl.ARRAY_BUFFER, particleQuadBuffer);
                gl.enableVertexAttribArray(particleRenderUniforms.quad);
                gl.vertexAttribPointer(particleRenderUniforms.quad, 2, gl.FLOAT, false, 0, 0);
                
                // Bind instance IDs
                gl.bindBuffer(gl.ARRAY_BUFFER, instanceIDBuffer);
                gl.enableVertexAttribArray(particleRenderUniforms.instanceID);
                gl.vertexAttribPointer(particleRenderUniforms.instanceID, 1, gl.FLOAT, false, 0, 0);
                instancingExt.vertexAttribDivisorANGLE(particleRenderUniforms.instanceID, 1);
                
                instancingExt.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, 4, PARTICLE_COUNT);
                
                instancingExt.vertexAttribDivisorANGLE(particleRenderUniforms.instanceID, 0);
                gl.disable(gl.BLEND);

                // ==================== COMPOSITE DISPLAY ====================
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.useProgram(displayCompositeProgram);
                
                gl.uniform2f(compositeUniforms.resolution, canvas.width, canvas.height);
                
                // Bind fluid texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, fluidField.getCurrentTexture());
                gl.uniform1i(compositeUniforms.fluid, 0);
                
                // Bind trail texture
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, trailField.getCurrentTexture());
                gl.uniform1i(compositeUniforms.trail, 1);
                
                
                
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.enableVertexAttribArray(compositeUniforms.pos);
                gl.vertexAttribPointer(compositeUniforms.pos, 2, gl.FLOAT, false, 0, 0);
                
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(render);
            }

            render();
        }

        init().catch(error => {
            console.error("Initialization error:", error);
        });
    </script>
</body>
</html>